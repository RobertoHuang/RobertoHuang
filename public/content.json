{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"Categories","date":"2017-12-20T13:25:21.998Z","updated":"2017-12-15T06:25:42.715Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2017-12-20T13:25:21.997Z","updated":"2017-12-17T13:23:29.100Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-12-20T13:25:21.999Z","updated":"2017-12-15T06:25:42.715Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"01.Spring源码深度解析之IDEA源码阅读环境搭建","slug":"01.Spring源码深度解析之IDEA源码阅读环境搭建","date":"2017-12-22T04:00:00.000Z","updated":"2017-12-22T04:27:41.735Z","comments":true,"path":"2017/12/22/01.Spring源码深度解析之IDEA源码阅读环境搭建/","link":"","permalink":"http://yoursite.com/2017/12/22/01.Spring源码深度解析之IDEA源码阅读环境搭建/","excerpt":"前言相信大部分人在面试过程中都会被问到是否阅读过Spring源码 Spring底层如何实现 Spring使用了哪些设计模式等问题，通常遇到这种问题我是直接选择死亡。因为开始我觉的花时间去研究一门框架不如多学习几个开源框架性价比来的高，可能花几天时间你能用一个新框架撸码，但是花几天时间研究Spring真的研究不出什么道来，不过渐渐的我发现程序员如果想自身的核心竞争力除了增加知识的广度外更重要的是能在某个方面有个深度。我想百分90的程序员都有在用Spring框架但是可能只有百分10不到的程序员研究过Spring框架，它是个十分成熟的开源框架，有着各路武林高手多年积淀下来的精华，为了应付面试也好提高自身编程思想也好我认为研究Spring源码还是很有必要的，因为阅读源码等同于你获得了一次和大师学习的机会，站在巨人的肩膀上才会看的更远","text":"前言相信大部分人在面试过程中都会被问到是否阅读过Spring源码 Spring底层如何实现 Spring使用了哪些设计模式等问题，通常遇到这种问题我是直接选择死亡。因为开始我觉的花时间去研究一门框架不如多学习几个开源框架性价比来的高，可能花几天时间你能用一个新框架撸码，但是花几天时间研究Spring真的研究不出什么道来，不过渐渐的我发现程序员如果想自身的核心竞争力除了增加知识的广度外更重要的是能在某个方面有个深度。我想百分90的程序员都有在用Spring框架但是可能只有百分10不到的程序员研究过Spring框架，它是个十分成熟的开源框架，有着各路武林高手多年积淀下来的精华，为了应付面试也好提高自身编程思想也好我认为研究Spring源码还是很有必要的，因为阅读源码等同于你获得了一次和大师学习的机会，站在巨人的肩膀上才会看的更远阅读Spring源码是一万次的心跳呼吸也是一万次的低头叹息，感觉还是很吃力特对对我这种没有源码阅读经验的菜鸡而言，但是每次坚持下来都会有意外的收获，读书百遍其义自见吧。在源码阅读过程中主要参考了郝佳的Spring源码深度解析，从代码角度进行剖析由浅入深，然后看源码过程中顺带看了些设计模式的内容，主要参考了程杰的大话设计模式，再然后还参考了数不清的技术博客，我们不生产水我们只是大自然的搬运工，我只是对这些大佬的见解进行汇总，如有侵权请及时联系。然后顺带安利个比较实用的UML图软件Visual Paradigm，页面简洁功能强大，谁用谁知道 然后再分享个看源码的经验吧，因为Spring源码层级结构较深，很容易就找不到自己想要定位的类，巧用IDEA的书签功能可以很好的解决该问题，IDEA的类图谱功能可以帮助我们理清类之间的依赖关系，Find Usages可以帮我们理清类之间的调用关系。再然后来个免责声明吧，本人不是高级软件开发工程师也不是什么架构师，只是一个刚刚学Java的菜鸡，菜的抠脚的那种，但是该博客是用心码出来的，所以如果你在看该博客有任何被坑的地方还请您多多担待，最后希望各位大佬不吝赐教不胜感激… 博客源码地址:https://github.com/RobertoHuang/spring-framework.git Spring整体架构网上找了一张Spring的架构框图，可以看出模块构成关系，了解即可不必过于纠结 Spring源码阅读环境构建下载Spring源码现在大型开源项目都由Github托管了，Spring也不例外。所以我们可以直接在Github上搜索spring-framework找到Spring项目下载ZIP包，或者直接通过以下命令检出Spring源码，如果对GIT还不了解的同学可以百度搜索廖雪峰GIT教程，相信很快就能上手1git clone https://github.com/spring-projects/spring-framework.git JDK版本最新版的Spring源码编译要求jdk1.8+版本，至于JDK环境变量配置在此就不赘述了 Gradle环境1234配置:1.创建系统环境变量:GRADLE_HOME 指向Gradle安装目录2.配置path:新增%GRADLE_HOME%\\bin;3.配置完成后打开CMD输入gradle -v看是否成功 IntelliJ IDEA版本阅读Spring源码对IntelliJ IDEA版本其实是没有要求的，但是不得不提一下的是如果你的IntelliJ IDEA版本是2017.1及以下的版本的话，那Gradle的版本用3.5的就可以了，用新版的Gradle可能会出问题 Spring源码编译并导入IDEA在下载下来的Spring源码的根目录下有个import-into-idea.md的文件，里面介绍了如何使用将Spring源码导入IDEA，并且讲述了在此过程中应该注意的一些问题，大致步骤如下 1.注释根目录settings.gradle文件下的jcenter()以及spring-aspects模块12345678pluginManagement &#123; repositories &#123; // jcenter() gradlePluginPortal() &#125;&#125;// include &quot;spring-aspects&quot; 2.注释spring-oxm下spring-oxm.gradle文件的jibx模块12345// jibx(verbose: true, load: true, binding: bindingXml) &#123; // classpathset(dir: sourceSets.test.java.outputDir) &#123; // include(name: &quot;**/jibx/**/*&quot;) // &#125;// &#125; 3.预编译spring-oxm模块，使用如下命令(此过程中可能由于网络问题失败 多重试几次)1gradle :spring-oxm:compileTestJava 4.导入项目到IDEA中，选择使用Gradle构建并配置Gradle环境 5.等待构建完成即可 至此Spring源码阅读环境已搭建完毕","categories":[{"name":"Spring源码深度解析","slug":"Spring源码深度解析","permalink":"http://yoursite.com/categories/Spring源码深度解析/"}],"tags":[{"name":"Spring源码深度解析","slug":"Spring源码深度解析","permalink":"http://yoursite.com/tags/Spring源码深度解析/"},{"name":"Spring源码环境搭建","slug":"Spring源码环境搭建","permalink":"http://yoursite.com/tags/Spring源码环境搭建/"}]},{"title":"02.Spring IOC源码深度解析之容器的基本实现","slug":"02.Spring IOC源码深度解析之容器的基本实现","date":"2017-12-22T04:00:00.000Z","updated":"2017-12-23T09:59:47.481Z","comments":true,"path":"2017/12/22/02.Spring IOC源码深度解析之容器的基本实现/","link":"","permalink":"http://yoursite.com/2017/12/22/02.Spring IOC源码深度解析之容器的基本实现/","excerpt":"在搭建完Spring源码阅读环境后，大家比较困惑的应该就是从哪里开始入手阅读Spring源码了。众所周知Spring的两大特性为IOC和AOP，那我们先以IOC为例跟进Spring源码。IOC(Inversion of Control):即”控制反转”，它不是什么技术而是一种设计思想，在传统的JAVA程序设计中当我们需要创建一个对象时，我们直接在对象内部通过new进行创建，而IOC是有一个专门的容器来控制对象的创建(即将对象的创建过程交由容器来完成) ，IOC也叫DI(Dependency Injection):DI即依赖注入，由容器动态的将某个依赖关系注入到组件之中，理解DI的关键是:谁依赖谁 为什么需要依赖 谁注入谁 注入了什么","text":"在搭建完Spring源码阅读环境后，大家比较困惑的应该就是从哪里开始入手阅读Spring源码了。众所周知Spring的两大特性为IOC和AOP，那我们先以IOC为例跟进Spring源码。IOC(Inversion of Control):即”控制反转”，它不是什么技术而是一种设计思想，在传统的JAVA程序设计中当我们需要创建一个对象时，我们直接在对象内部通过new进行创建，而IOC是有一个专门的容器来控制对象的创建(即将对象的创建过程交由容器来完成) ，IOC也叫DI(Dependency Injection):DI即依赖注入，由容器动态的将某个依赖关系注入到组件之中，理解DI的关键是:谁依赖谁 为什么需要依赖 谁注入谁 注入了什么 容器基本用法为了更好的理解Spring源码，后续我们会创建许多的测试案例。为了保证逻辑清晰我选择的是在spring-framework项目下新建一个独立的模块spring-roberto，该模块通过引用其他子模块来完成功能测试 在spring-framework下新增子模块spring-roberto，并修改gradle配置内容如下(添加了spring-beans的依赖)123456789101112131415group &apos;org.springframework&apos;version &apos;5.0.3.BUILD-SNAPSHOT&apos;apply plugin: &apos;java&apos;sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; compile(project(&quot;:spring-beans&quot;)) testCompile group: &apos;junit&apos;, name: &apos;junit&apos;, version: &apos;4.12&apos;&#125; Spring IOC的简单实现新建实体类TestBean.java12345678910111213package _01.ioc_simple_impl;public class TestBean &#123; private String str = &quot;testStr&quot;; public String getStr() &#123; return str; &#125; public void setStr(String str) &#123; this.str = str; &#125;&#125; 新建applicationContext.xml文件1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;testBean&quot; class=&quot;org.springframework.roberto._01_iocsimpleimpl.TestBean&quot; /&gt;&lt;/beans&gt; 新建测试类1234567891011121314151617package org.springframework.roberto;import org.junit.Test;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.xml.XmlBeanFactory;import org.springframework.core.io.ClassPathResource;import org.springframework.roberto._01_iocsimpleimpl.TestBean;@SuppressWarnings(&quot;deprecation&quot;)public class _01_IocSimpleImplTest &#123; @Test public void testSimpleLoad() &#123; BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;01.ioc_simple_impl.xml&quot;)); TestBean testBean = (TestBean) beanFactory.getBean(&quot;testBean&quot;); System.out.println(testBean.getStr()); &#125;&#125; 运行结果输出testStr，到此我们已经实现了IOC的功能。这个过程非常的简单但是内部实现原理却是九曲十八弯，相信你在看完后续的源码解析时，你也会对封装有一个更好的理解(特别是等研究源码半个月或者一个月发现其实你只跟进阅读2行代码时) 容器功能分析以上测试代码主要帮我们完成如下几个功能:1231.读取applicationContext.xml文件2.根据applicationContext.xml中的配置找到对应类的配置并实例化3.调用实例化后的实例，返回结果 资源文件的加载资源文件加载的代码为:1BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;applicationContext.xml&quot;)); 时序图: 通过时序图可以很清楚的看出资源加载过程是:121.先将配置文件读取成Resource资源文件的实例对象2.然后再对XmlBeanFactory进行初始化操作 加载配置文件new ClassPathResource(“applicationContext.xml”)过程分析1234567891011public ClassPathResource(String path, @Nullable ClassLoader classLoader) &#123; Assert.notNull(path, &quot;Path must not be null&quot;); // 对配置文件路径进行处理 String pathToUse = StringUtils.cleanPath(path); if (pathToUse.startsWith(&quot;/&quot;)) &#123; pathToUse = pathToUse.substring(1); &#125; // 初始化path和classLoader this.path = pathToUse; this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());&#125; Spring配置文件的加载使用ClassPathResource，打开ClassPathResource类继承结构发现它实现了Resource接口。Resource接口抽象了所有Spring内部使用到的底层资源:File、URL、Classpath等，并且Resource接口提供了几个重要的方法如:存在性(exists)、可读性(isReadable)、是否处于打开状态(isOpen) 。对不同来源的资源文件Spring都内置了不同的Resource实现，如:文件(FileSystemResource)、Classpath资源(ClassPathResource)、URL资源(UrlResource)、InputStream资源(InputStreamResource)、Byte数组(ByteArrayResource)等 同时Resource继承了InputStreamSource接口，InputStreamSource封装任何能返回InputStream的类，它只有一个方法定义:getInputStream()，该方法返回一个InputStream对象。在日常开发工作中资源文件的加载也是经常用到的，可以直接使用Spring提供的类，比如在加载文件时可以使用如下代码:12Resource resource = new ClassPathResource(&quot;applicationContext.xml&quot;);InputStream inputStream = resource.getInputStream(); 加载XmlBeanFactorynew XmlBeanFactory(resource)过程分析1234567public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException &#123; // ignoreDependencyInterface(BeanNameAware.class); // ignoreDependencyInterface(BeanFactoryAware.class); // ignoreDependencyInterface(BeanClassLoaderAware.class); super(parentBeanFactory); this.reader.loadBeanDefinitions(resource);&#125; 在super(parentBeanFactory)方法中调用了ignoreDependencyInterface(Class&lt;?&gt; ifc)方法，以下是郝佳Spring源码深度解析中对ignoreDependencyInterface(Class&lt;?&gt;&gt; ifc)的解释1举例来说当A中有属性B，那么当Spring在获取A的Bean的时候如果其属性B还没有初始化，那么Spring会自动初始化B，这也是Spring中提供的一个重要特性。但是某些情况下B不会被初始化，其中的一种情况就是B实现了BeanNameAware接口。Spring中是这样介绍的:自动装配时忽略给定的依赖接口，典型应用是通过其他方式解析Application上下文注册依赖，类似于BeanFactory通过BeanFactoryAware进行注入或者ApplicationContext通过ApplicationContextAware进行注入 经过尝试发现即使属性B实现了以上接口还是会被初始化，经过查看源码个人认为以上的理解并不正确。我认为此处说的忽略自动注入是指:假设A实现了BeanFactoryAware接口重写了setBeanFactory方法，那么属性beanFactory是不能通过自动注入方式进行注入。 源码分析过程:ignoreDependencyInterface(Class&lt;?&gt; ifc)方法实现的功能其实是往ignoredDependencyInterfaces中添加Class，而通过Find Usage查找调用链发现使用ignoredDependencyInterfaces属性进行判断的方法为AbstractAutowireCapableBeanFactory中的isExcludedFromDependencyCheck，继续搜索调用链找到AbstractAutowireCapableBeanFactory中的unsatisfiedNonSimpleProperties，而unsatisfiedNonSimpleProperties是在AbstractAutowireCapableBeanFactory中的autowireByName和autowireByType中调用的。即在autowireByName和autowireByType方法中如果发现类继承了对应的以上三个接口，那么对应的属性是会被忽略注入的。 注:在Spring不是所有类型都能自动装配，Object，基本数据类型及(Date CharSequence Number URI URL Class)等是不会被自动装配的，此处的自动装配指配置文件中的autowire而非注解@Autowired 加载Bean的主要逻辑是在this.reader.loadBeanDefinitions(resource);中执行的，下面为该方法的时序图123456789101112131415161718192021222324252627282930313233343536public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123; Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;); if (logger.isInfoEnabled()) &#123; logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource()); &#125; Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) &#123; currentResources = new HashSet&lt;&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); &#125; // 配置文件循环引入检查(在配置文件中import自己即可进入该异常) if (!currentResources.add(encodedResource)) &#123; throw new BeanDefinitionStoreException(&quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;); &#125; try &#123; InputStream inputStream = encodedResource.getResource().getInputStream(); try &#123; InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) &#123; inputSource.setEncoding(encodedResource.getEncoding()); &#125; // 加载Bean return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); &#125; finally &#123; inputStream.close(); &#125; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException(&quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex); &#125; finally &#123; currentResources.remove(encodedResource); if (currentResources.isEmpty()) &#123; this.resourcesCurrentlyBeingLoaded.remove(); &#125; &#125;&#125; 该方法可拆分为数据准备和核心处理两个部分，核心部分代码为doLoadBeanDefinitions(inputSource, encodedResource.getResource()); 123456789101112131415161718protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException &#123; try &#123; Document doc = doLoadDocument(inputSource, resource); return registerBeanDefinitions(doc, resource); &#125; catch (BeanDefinitionStoreException ex) &#123; throw ex; &#125; catch (SAXParseException ex) &#123; throw new XmlBeanDefinitionStoreException(resource.getDescription(), &quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex); &#125; catch (SAXException ex) &#123; throw new XmlBeanDefinitionStoreException(resource.getDescription(), &quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex); &#125; catch (ParserConfigurationException ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), &quot;Parser configuration exception parsing XML from &quot; + resource, ex); &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), &quot;IOException parsing XML document from &quot; + resource, ex); &#125; catch (Throwable ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), &quot;Unexpected exception parsing XML document from &quot; + resource, ex); &#125;&#125; 以上为Bean加载核心处理部分代码，总共处理了两件事，一是解析配置的XML文件转为Document对象，二是根据解析出来的Document注册Bean信息 解析配置的XML文件转为Document对象过程12345protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception &#123; // getEntityResolver()获取EntityResolver对象 // getValidationModeForResource(resource) 获取资源校验模式 return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler, getValidationModeForResource(resource), isNamespaceAware());&#125; 在执行loadDocument操作前做了两个准备工作，第一是获取EntiryResolver对象，第二是获取XML校验模式，最后根据这些参数解析XML配置文件转换为Document 官网对于EntityResolver的解释为:如果SAX应用程序需要实现自定义处理外部实体，则必须实现此接口。解析一个XML文件，SAX首先读取该XML文档上的说明，根据声明去寻找对应的DTD定义，以便对文档进行一个验证。默认是通过网络下载对应的声明的，但是该过程容易因为网络问题等原因导致出错，EntityResolver的作用是项目本身就可以提供一个如何寻找DTD声明的方法(org.springframework.beans.factory.xml.ResourceEntityResolver#resolveEntity(String publicId, String systemId)),即由程序来实现寻找DTD声明的过程(该部分代码不影响理解Spring主流程 了解即可) getValidationModeForResource(resource)执行过程:123456789101112131415protected int getValidationModeForResource(Resource resource) &#123; // 判断是否手动设置了校验模式 int validationModeToUse = getValidationMode(); if (validationModeToUse != VALIDATION_AUTO) &#123; return validationModeToUse; &#125; // 判断配置文件中是否有DOCTYPE字段 区分是DTD还是XSD int detectedMode = detectValidationMode(resource); if (detectedMode != VALIDATION_AUTO) &#123; return detectedMode; &#125; // 默认为XSD方式解析 return VALIDATION_XSD;&#125; loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware):12345678public Document loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception &#123; DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;); &#125; DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler); return builder.parse(inputSource);&#125; 这部分代码没啥好说的，就是使用最原始的javax.xml.parsers解析配置的XML文件转为Document过程，至此我们已经将配置文件XML=&gt;Document对象了 解析及注册BeanDefinitions12345678910public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123; // 新建BeanDefinitionDocumentReader实例对象(DefaultBeanDefinitionDocumentReader) BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); // 记录统计前BeanDefinition加载个数 int countBefore = getRegistry().getBeanDefinitionCount(); // 加载注册Bean documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); // 记录本次加载的BeanDefinition个数 return getRegistry().getBeanDefinitionCount() - countBefore;&#125; 加载注册Bean执行过程:123456public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123; this.readerContext = readerContext; logger.debug(&quot;Loading bean definitions&quot;); Element root = doc.getDocumentElement(); doRegisterBeanDefinitions(root);&#125; 经过艰难险阻磕磕碰碰，终于接触到了核心逻辑的底部doRegisterBeanDefinitions(root);如果说之前一直是XML加载解析准备阶段，那么doRegisterBeanDefinitions(root);算是真正的开始解析了 123456789101112131415161718192021222324252627282930protected void doRegisterBeanDefinitions(Element root) &#123; BeanDefinitionParserDelegate parent = this.delegate; // 创建Bean解析代理对象 实际上正在的解析过程是在BeanDefinitionParserDelegate这个代理中 this.delegate = createDelegate(getReaderContext(), root, parent); // 处理Profile属性 if (this.delegate.isDefaultNamespace(root)) &#123; String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) &#123; String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123; if (logger.isInfoEnabled()) &#123; logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec + &quot;] not matching: &quot; + getReaderContext().getResource()); &#125; return; &#125; &#125; &#125; // 解析前操作 为了扩展交给子类实现 preProcessXml(root); // 解析过程 parseBeanDefinitions(root, this.delegate); // 解析后操作 为了扩展交给子类实现 postProcessXml(root); this.delegate = parent;&#125; 创建Bean解析代理对象过程解析:1234567protected BeanDefinitionParserDelegate createDelegate(XmlReaderContext readerContext, Element root, @Nullable BeanDefinitionParserDelegate parentDelegate) &#123; // 新建BeanDefinitionParserDelegate对象 BeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext); // 参数初始化 delegate.initDefaults(root, parentDelegate); return delegate;&#125; 先是调用构造函数新建BeanDefinitionParserDelegate实例，然后调用initDefaults(root, parentDelegate);对参数进行初始化 123456public void initDefaults(Element root, @Nullable BeanDefinitionParserDelegate parent) &#123; // 对DocumentDefaultsDefinition属性进行初始化 populateDefaults(this.defaults, (parent != null ? parent.defaults : null), root); // 对外开放口子 用于修改DocumentDefaultsDefinition属性的默认值 this.readerContext.fireDefaultsRegistered(this.defaults);&#125; 在参数初始化过程中主要完成了两件事，一是通过populateDefaults方法对属性defaults:DocumentDefaultsDefinition进行初始化(涉及属性有default lazy-init, autowire, dependency check settings, init-method, destroy-method and merge settings)，二是提供口子用于修改DocumentDefaultsDefinition的参数值(Spring只提供了空实现 若要使用该功能需自行拓展) 关于Spring提供的这个口子，我在网上看到一个写的很好的Demo。背景是工程单元测试希望和生产环境共用一份Spring配置文件，生产环境应用为了客户体验使用非LazyInit模式，但是单元测试下为了提高响应时间希望LazyInit 1.新建自定义事件监听器1234567891011121314151617181920212223242526272829package org.springframework.roberto._03_lazy_init;import org.springframework.beans.factory.parsing.*;import org.springframework.beans.factory.xml.DocumentDefaultsDefinition;public class CustomerEventListener implements ReaderEventListener &#123; @Override public void defaultsRegistered(DefaultsDefinition defaultsDefinition) &#123; if (defaultsDefinition instanceof DocumentDefaultsDefinition) &#123; DocumentDefaultsDefinition defaults = (DocumentDefaultsDefinition) defaultsDefinition; defaults.setLazyInit(&quot;true&quot;); &#125; &#125; @Override public void componentRegistered(ComponentDefinition componentDefinition) &#123; &#125; @Override public void aliasRegistered(AliasDefinition aliasDefinition) &#123; &#125; @Override public void importProcessed(ImportDefinition importDefinition) &#123; &#125;&#125; 新建LazyInitClasspathXmlApplicationContext类继承ClassPathXmlApplicationContext 并重写initBeanDefinitionReader方法1234567891011121314151617package org.springframework.roberto._03_lazy_init;import org.springframework.beans.BeansException;import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;import org.springframework.context.support.ClassPathXmlApplicationContext;public class LazyInitClasspathXmlApplicationContext extends ClassPathXmlApplicationContext &#123; public LazyInitClasspathXmlApplicationContext(String... configLocations) throws BeansException &#123; super(configLocations); &#125; @Override protected void initBeanDefinitionReader(XmlBeanDefinitionReader reader) &#123; super.initBeanDefinitionReader(reader); reader.setEventListener(new CustomerEventListener()); &#125;&#125; 新建实体类TestLazyInitBean123456789101112package org.springframework.roberto._03_lazy_init;public class TestLazyInitBean &#123; public void init() &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;TestBean Init&quot;); &#125;&#125; 修改配置文件如下1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;testLazyInitBean&quot; class=&quot;org.springframework.roberto._03_lazy_init.TestLazyInitBean&quot; init-method=&quot;init&quot;/&gt;&lt;/beans&gt; 测试方法如下123456789101112131415161718package org.springframework.roberto;import org.junit.Test;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.roberto._03_lazy_init.LazyInitClasspathXmlApplicationContext;public class _03_LazyInitTest &#123; @Test public void testLayzyInit() &#123; long currentTime = System.currentTimeMillis(); new ClassPathXmlApplicationContext(&quot;03.lazy_init.xml&quot;); System.out.println(&quot;No LazyInit Cost Time:&quot; + (System.currentTimeMillis() - currentTime)); currentTime = System.currentTimeMillis(); new LazyInitClasspathXmlApplicationContext(&quot;03.lazy_init.xml&quot;); System.out.println(&quot;LazyInit Cost Time:&quot; + (System.currentTimeMillis() - currentTime)); &#125;&#125; 测试结果123TestBean InitNo LazyInit Cost Time:6203LazyInit Cost Time:37 测试结果表明这里确实改变了Spring的懒加载设置，其实此处原理就是修改了ReaderContext的ReaderEventListener的实现 这里使用ClassPathXmlApplicationContext方式测试是因为BeanFactory采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean)才对该Bean进行加载实例化，我们就不能发现一些存在的Spring配置问题，而ApplicationContext则相反它是在容器启动时一次性创建了所有的Bean，这样在容器启动时，我们就可以发现Spring中存在的错误。相对于BeanFactory而言，ApplicationContext唯一的不足就是占用内存空间，当应用程序配置Bean较多时程序启动慢 对profiles属性使用解析:修改applicationContext.xml配置文件如下: (最外层beans的profile属性为可能出现的环境 内层的profile指向具体环境)12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;beans profile=&quot;dev&quot;&gt; &lt;bean id=&quot;testProfileBean&quot; class=&quot;org.springframework.roberto._04_profile.TestProfileBean&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; &lt;beans profile=&quot;test&quot;&gt; &lt;/beans&gt;&lt;/beans&gt; 新建测试类123456789101112131415161718package org.springframework.roberto;import org.junit.Test;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.xml.XmlBeanFactory;import org.springframework.core.io.ClassPathResource;import org.springframework.roberto._04_profile.TestProfileBean;@SuppressWarnings(&quot;all&quot;)public class _04_ProfileTest &#123; @Test public void testProfile() &#123; System.setProperty(&quot;spring.profiles.active&quot;,&quot;dev&quot;); BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;04.profile.xml&quot;)); TestProfileBean testProfileBeant = (TestProfileBean) beanFactory.getBean(&quot;testProfileBean&quot;); System.out.println(testProfileBeant); &#125;&#125; 测试通过说明dev配置是生效的，若将spring.profiles.active设置成test测试不通过。在集成到Web环境中时，可以在web.xml中加入以下代码1234&lt;context-param&gt; &lt;param-name&gt;spring.profiles.active&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt; &lt;/context-param&gt; 有了这个特性我们就可以同时在配置文件中部署两套配置来适用于生产环境和开发环境，这样可以方便的进行切换开发、部署环境，最常用的就是更换不同的数据库了(这种方式其实并不直观 现在项目大多数是Maven项目 Maven的profiles对多环境支持更强大)","categories":[{"name":"Spring源码深度解析","slug":"Spring源码深度解析","permalink":"http://yoursite.com/categories/Spring源码深度解析/"}],"tags":[{"name":"Spring源码深度解析","slug":"Spring源码深度解析","permalink":"http://yoursite.com/tags/Spring源码深度解析/"},{"name":"IOC源码解析","slug":"IOC源码解析","permalink":"http://yoursite.com/tags/IOC源码解析/"},{"name":"Spring容器实现","slug":"Spring容器实现","permalink":"http://yoursite.com/tags/Spring容器实现/"},{"name":"Spring配置加载","slug":"Spring配置加载","permalink":"http://yoursite.com/tags/Spring配置加载/"}]},{"title":"前辈分享的经典语句","slug":"前辈分享的经典语句","date":"2017-12-12T04:12:12.000Z","updated":"2017-12-17T13:21:35.158Z","comments":true,"path":"2017/12/12/前辈分享的经典语句/","link":"","permalink":"http://yoursite.com/2017/12/12/前辈分享的经典语句/","excerpt":"一个人的心态很重要心量小的人 芝麻大小的事情也能在心里翻江倒海心量大的人 即使在危机面前也能镇定自若同样一件事情 掀起的波澜大小缺因人而异有一句话很好 用于技术人员我觉得尤其合适想要成为一棵大树 就不要去和草争","text":"一个人的心态很重要心量小的人 芝麻大小的事情也能在心里翻江倒海心量大的人 即使在危机面前也能镇定自若同样一件事情 掀起的波澜大小缺因人而异有一句话很好 用于技术人员我觉得尤其合适想要成为一棵大树 就不要去和草争 一个人的成就 不可以用金钱来衡量而是一生中 你善待过多少人 有多少人怀恋你成功并非单指事业无论是爱好或职业上的成功都只是成就成功应该是多元化的如人的一生包含了很多追求一样 而非单一指向然后 无论你多有成就真正的成功 就是陪伴家人所有的情感都是需要陪伴的这些陪伴成为一个个美好的记忆这些都是整个家庭最宝贵 最重要的财富这些远远超过物质的重要性 在中国因为价值观相对比较单一社会显得浮躁 很物质所以大多以物质的追求为主越多越好 内心也想过美好的生活但当你的心完全趋向于金钱的时候很多美好的东西就自动屏蔽了不会出现在生活中别让忙碌空白了回忆 此外作为一名技术人员 我觉得职业生涯中可能很多次需要面对工作的变换 角色的变化有很多知识需要学习所以 我们应该把“归零”当成一种生活的新常态","categories":[{"name":"个人博客","slug":"个人博客","permalink":"http://yoursite.com/categories/个人博客/"}],"tags":[{"name":"心灵鸡汤","slug":"心灵鸡汤","permalink":"http://yoursite.com/tags/心灵鸡汤/"}]}]}